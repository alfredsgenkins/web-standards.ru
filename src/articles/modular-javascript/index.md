---
title: 'Принцип мозаики, или как мы сделали JavaScript по-настоящему модульным'
date: 2021-04-26
author: alfreds-genkins
editors:
    - vadim-makeev
tags:
    - article
    - javascript
---

Идея родилась и развивалась внутри нашего OSS проекта ScandiPWA – «витрины» для онлайн--коммерции на React. Нашей главной задачей было разработать расширяемую основу для наших проектов, в которую мы могли бы внедрять расширения, при этом имея возможность менять облик (создавать темы) как самой основы, так и любого из расширений. При этом, важно было предоставить возможность быстрого и удобного их (базы и расширений) обновления.

Попробовав множество подходов, мы пришли к выводу, что для решения нашей задачи, нам абсолютно не подходят решения, предусматривающие полное копирование всей кодовой базы каждым из разрабатываемых проектов. Часто применяемый вариант с применением git-fork заставлял раз в неделю резолвить огромное количество merge-конфликтов, что было просто непозволительно учитывая сжатые сроки наших проектов.

С расширениями дела обстояли еще хуже. Потребность в них росла, а конвенциональные подходы к этой проблеме заставляли на каждом шагу останавливаться, и оставлять места для внедрения плагинов. В приложении таких набиралось все больше, и нас это решительно не устраивало, код регистрации точки внедрения дублировался, а следить и документировать каждый становилось просто невозможно. Наш опыт с backend языками подсказывал, что должен был быть способ внедрять плагины на уровне кода, а не разбросанных по приложения точек выхода. Однако JavaScript такой возможности, из коробки, не предоставлял.

Мы долго задавались вопросом: как живут все больше проекты в вебе, искали подходы, технологии… Даже тогда, 2 года назад, когда мы только начинали, уже были технологии типа «di». И все с ними хорошо, да есть у нас проблема: наш продукт ScandiPWA делался для простых ребят. Закоренелых PHP разработчиков. Для тех, кто зачастую React в первый раз видел. Приходилось прямо в документации рассказывать о преимуществах над JQuery… Представьте как сложно было бы объяснить непонятные registry…

Вообщем, нам нужно было что-то элементарно простое. Пришлось, как принято, делать самим.

## К чему мы пришли (плагины)

Как уже сказано выше, чтобы работать с плагинами, обычно приходится писать еще и кучу кода. Расставлять точки входа, регистрировать, импортировать файлы регистрации… Это все долго, сложно, затратно и очень плохо масштабируется. Мы решили, что все это можно убрать. Скрыть, и делать плагины сразу к самому коду. Мы очень не хотели менять прототипы, мы хотели чтобы плагины просто перехватывали вызов той или иной функции и позволяли модифицировать процесс и результат ее выполнения. Важно, при этом, было работать на уровне стека вызова оригинальной функции, чтобы программу было легко отлаживать.

И так, что же мы там придумали? А вот что: теперь, вы можете делать сущности вашего языка в вашем приложении (функции, классы и методы) точкой входа для плагинов с помощью всего одного комментария! Комментарий - `@namespace` позволит изменить отмеченную сущность через плагины из любого модуля в приложении. А еще он прекрасно подсвечивается вашим редактором! Вот как это в итоге выглядит:

```javascript
/** @namespace Application/getData */
const getData = () => {
    return ['Initial data'];
}

console.log(getData());
```

И что, это все? Да, все. Теперь вы можете расширять эту функцию, например, добавить к результату ее выполнения новый элемент, сделать это, достаточно просто, смотрите:

```javascript
export default {
    'Application/getData': { // тот самый @namespace нашей функции
        function: (args, callback) => { // тип изменяемой сущности
            return [
                ...callback(...args), // вызов оригинальной функции
                'Data from the plugin' // наш новый элемент
            ];
        }
    }
}
```

А как решить проблему с импортом файлов регистрации? Определить для них одно место, и брать оттуда! Забегая немного вперед, система ищет плагины по паттерну `src/plugin/*.plugin.*` во всех отмеченных модулях приложения.

Точно таким же образом это работает с классами, методами класса, их статическими методами, свойствами и даже стрелочными функциями. Просто добавь неймспейс!

## К чему мы пришли (темы)

А что с темами? Мы бы хотели надстраивать их бесконечное количество (ну или больше двух!) друг на друге. Например так:
1. Голая тема с чистым функционалом
2. Красивая тема №101
3. Кастомизации под клиента

Для нас, ответ крылся в формулировке вопроса – ”надстраивать друг-на-друге”. Мы решили сделать все уже давно изведанным во многих backend фреймворках способом: при сборке предпочитать файлы детей родительским, в случае, если имена их файлов совпадают! Непонятно? Вот как это работает на практике (спойлер, все просто!):

```javascript
// этот файл лежит в пакете krasivaja-tema файле App.js
import { PureComponent } from 'react';

export default class App extends PureComponent {
  render() {
    return <p>Это написано в Красивой теме №101</p>;
  }
}
```

```javascript
// это файл уже более "молодой" темы "Кастомизации под клиента"
// но имя файла (что важно!) совпадает, тоже App.js
import ParentApp from 'krasivaja-tema/App';

export default class App extends ParentApp {
  render() {
    return (
       <>
          { super.render() }
          <p>А это в Кастомизации под клиента</p>
       </>
    );
  }
}
```

В результате получаем следующий HTML в результате рендера:

```html
<p>Это написано в Красивой теме №101</p>
<p>А это в Кастомизации под клиента</p>
```

Обратите внимание, мы использовали классы и наследование в React! Такая практика считается не рекомендованной. Однако, в нашем случае, она решает больше проблем, чем создает:
- Программист может сам решать, хочет ли он остаться совместимым с оригинальной темой (и сильно упростить последующие обновления), или же он хочет переписать файл с нуля. В таком случае, он может просто создать класс с нуля (из PureComponent)
- Мы имеем возможность наследовать методы частями. Например нас устраивает, как рендерится название, но мы недовольны ценой. Мы всегда можем переписать лишь несколько конкретных, необходимых нам методов.
- Наконец, мы можем на уровне метода или свойства решать, хотим ли мы унаследовать его (через обращение к super).

Еще, и это важно, мы не даем возможность больше обратиться напрямую к классу родительской темы, если он переписан в более “молодой”. Теперь, любое обращение к нему вернет вам ваш новый, переписанный класс! Поэтому, мы считаем такой подход валидным, и несмотря на популярность функциональных компонентов в React продолжаем использовать классовые!

## Как это попробовать?

Все опять же, очень просто. На самом деле, механизм может работать не только с React как плагины так и темы можно делать для любых сущностей/файлов. Мы же пока уверенно можем заявить о поддержке самых популярных фреймворков: create-react-app и next. Что, плагины в Next? Да-да! Плагины в Next!

Как выглядит интеграция? До боли просто. Достаточно заменить зависимость с `react-scripts` на `@tilework/mosaic-cra-scripts` а в самих скриптах, аналогично с `react-scripts` на `cra-scripts`. И все! Вот как это выглядит:

```json
"dependencies": {
    "@tilework/mosaic-cra-scripts": "0.0.2",
    // "react-scripts": "4.0.3",
    ...
},
"scripts": {
    // "start": "react-scripts start",
    // "build": "react-scripts build",
    "start": "cra-scripts start",
    "build": "cra-scripts build",
    ...
}
```

Для Next, все точно также, только ставить надо `@tilework/mosaic-nextjs-scripts` а скрипты менять нужно на `nextjs-scripts`.

Что делать всем остальным? Ну если ваш стек это webpack и babel, то и для вас есть очень простое решение: ставим `@tilework/mosaic-config-injectors` и изменяем вашу webpack конфигурацию следующим образом:

```javascript
const webpack = require('webpack');
const ConfigInjectors = require('@tilework/mosaic-config-injectors');

module.exports = ConfigInjectors.injectWebpackConfig({
    ... // ваша конфигурация
}, {
    webpack
});
```

Готово? Ура! Поделитесь опытом использования, для нас это очень важно!

## Почему все-таки mosaic?

Чем картины отличаются от мозаики? Мозаика состоит из отдельных элементов, а картина, хоть и окрашена в разные цвета, является одним, неразделимым целым.

Большинство приложений JavaScript - это картины. Наше изначальное – ScandiPWA, тоже. Даже разделив такое приложение на модули, нам все равно придется их переплетать, интегрируя один в другой. Модули - как цвета на картине, изначально выходящие из разных тюбиков, оказываются неразрывно связанными в одно целое.

Однако есть способ превратить приложения написанные на JavaScript в настоящую мозаику. Модули таких приложений должны содержат в себе свою собственную интеграцию. Они больше не будут переплетаться на холсте, как краски, а их будет достаточно “выложить” в определенном порядке, как плитку мозаики.

Плагины позволят вам сделать это! Да, да! Мы начали с интеграций в уже готовые приложения, а теперь предлагаем написать все с нуля? Что? Ага, мы сами в шоке!

Но как это вам поможет? Какие проблемы решит? Да, честно говоря, вы просто напишете приложение изначально думая о том, как его можно будет расширять. И не только сторонними расширениями, но и собственной дополнительной логикой. Это зарядка для мозга, полезная сложность, которая делает наш код немного более качественным!

Наверное, не стоит переписывать уже готовые приложения на этот подход, но вот писать новые… Стоит попробовать! Особенно в случае, если вы хотите в будущем легко заменять одни его части на другие. Подумайте об этом :)

## Ссылки

Вот наши доки (они вечно в процессе, извините!): [https://docs.mosaic.js.org/](https://docs.mosaic.js.org/)

А вот и сам репозиторий: [https://github.com/tilework/mosaic](https://github.com/tilework/mosaic)

Интересно, с чего все это началось? Вот, это Scandipwa, наша витрина для э-коммерции! [https://github.com/scandipwa/scandipwa](https://github.com/scandipwa/scandipwa)

А вот пример проекта написанного с использованием mosaic подхода (полностью модульно): [https://github.com/scandipwa/shopify](https://github.com/scandipwa/shopify)